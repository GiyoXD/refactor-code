def fill_invoice_data(
    worksheet: Worksheet,
    sheet_name: str,
    sheet_config: Dict[str, Any], # Keep current sheet config param
    all_sheet_configs: Dict[str, Any], # <--- Add param for all sheet configs
    data_source: Union[Dict[str, List[Any]], Dict[Tuple, Dict[str, Any]]],
    data_source_type: str,
    header_info: Dict[str, Any],
    mapping_rules: Dict[str, Any],
    sheet_styling_config: Optional[Dict[str, Any]] = None,
    add_blank_after_header: bool = False,
    static_content_after_header: Optional[Dict[str, Any]] = None,
    add_blank_before_footer: bool = False,
    static_content_before_footer: Optional[Dict[str, Any]] = None,
    merge_rules_after_header: Optional[Dict[str, int]] = None,
    merge_rules_before_footer: Optional[Dict[str, int]] = None,
    merge_rules_footer: Optional[Dict[str, int]] = None, # Added footer merge rules
    footer_info: Optional[Dict[str, Any]] = None, # Currently unused
    max_rows_to_fill: Optional[int] = None,
    grand_total_pallets: int = 0, # RE-ADDED parameter
    custom_flag: bool = False, # Added custom flag parameter
    data_cell_merging_rules: Optional[Dict[str, Any]] = None, # Added data cell merging rules 29/05/2025
    ) -> Tuple[bool, int, int, int, int]: # Still 5 return values
    """
    REVISED LOGIC V13: Added merge_rules_footer parameter.
    Footer pallet count uses local_chunk_pallets for processed_tables,
    and grand_total_pallets for aggregation/fob_aggregation.
    """

    # --- Initialize Variables --- (Keep existing initializations)
    actual_rows_to_process = 0; data_rows_prepared = []; col1_index = 1; num_static_labels = 0
    static_column_header_name = None; data_row_indices_written = [];
    columns_to_grid = []
    desc_col_idx = None
    local_chunk_pallets = 0
    dynamic_desc_used = False



    # get data source pallet count and hanle null
    for pallet_count in data_source.get("pallet_count", []):
        if pallet_count is not None:
            local_chunk_pallets += pallet_count

    # --- Row Index Tracking --- (Keep existing)
    row_after_header_idx = -1
    data_start_row = -1
    data_end_row = -1
    row_before_footer_idx = -1
    footer_row_final = -1

    # Ensure dictionaries/lists are initialized (Keep existing)
    static_content_after_header = static_content_after_header or {}
    static_content_before_footer = static_content_before_footer or {}
    merge_rules_after_header = merge_rules_after_header or {}
    merge_rules_before_footer = merge_rules_before_footer or {}
    merge_rules_footer = merge_rules_footer or {} # Initialize footer merge rules
    mapping_rules = mapping_rules or {}
    col_id_map = header_info.get('column_id_map', {})
    column_map = header_info.get('column_map', {})
    idx_to_header_map = {v: k for k, v in column_map.items()}


    try:
        data_cell_merging_rules = data_cell_merging_rules or {}
        # --- Validate Header Info ---
        if not header_info or 'second_row_index' not in header_info or 'column_map' not in header_info or 'num_columns' not in header_info:
            print("Error: Invalid header_info provided.")
            return False, -1, -1, -1, 0

        # --- FIX: Extract num_columns and other values from header_info ---
        num_columns = header_info['num_columns']
        data_writing_start_row = header_info['second_row_index'] + 1
 
        # --- Find Description & Pallet Info Column Indices --- (Keep existing)
        desc_col_idx = col_id_map.get("col_desc")
        pallet_info_col_idx = col_id_map.get("col_pallet")
        if pallet_info_col_idx is None: print("Warning: Header 'Pallet Info' not found.")

        # --- ADD/MODIFY THIS PART FOR PALLET INFO INDEX ---
        if pallet_info_col_idx is None:
            print("Warning: Could not find a 'Pallet Info' (e.g., 'Pallet\\nNo') column header.")
        # --- END OF ADDITION/MODIFICATION FOR PALLET INFO INDEX ---

        # --- Get Styling Config --- (Keep existing)
        force_text_headers = []
        effective_header_font = bold_font # Start with default
        effective_header_align = center_alignment # Start with default

        if sheet_styling_config:
            columns_to_grid = sheet_styling_config.get("column_ids_with_full_grid", [])
            if not isinstance(columns_to_grid, list): columns_to_grid = []

            force_text_headers = sheet_styling_config.get("force_text_format_ids", [])
            if not isinstance(force_text_headers, list): force_text_headers = []

            header_font_cfg = sheet_styling_config.get("header_font")
            if header_font_cfg and isinstance(header_font_cfg, dict):
                 font_params = {k: v for k, v in header_font_cfg.items() if v is not None}
                 if font_params:
                     try: # Expanded try block
                         effective_header_font = Font(**font_params)
                     except TypeError:
                         print(f"Warning: Invalid parameters in header_font config: {font_params}. Using default.")
                         pass # Keep default font on error
                     except Exception as font_err: # Catch other potential errors
                         print(f"Warning: Error applying header_font config: {font_err}. Using default.")
                         pass # Keep default font on error

            header_align_cfg = sheet_styling_config.get("header_alignment")
            if header_align_cfg and isinstance(header_align_cfg, dict):
                 align_params = {k: v for k, v in header_align_cfg.items() if v is not None}
                 if align_params:
                     try: # Expanded try block
                         effective_header_align = Alignment(**align_params)
                     except TypeError:
                         print(f"Warning: Invalid parameters in header_alignment config: {align_params}. Using default.")
                         pass # Keep default alignment on error
                     except Exception as align_err: # Catch other potential errors
                          print(f"Warning: Error applying header_alignment config: {align_err}. Using default.")
                          pass # Keep default alignment on error
        parsed_rules = parse_mapping_rules(
            mapping_rules=mapping_rules,
            column_id_map=col_id_map,
            idx_to_header_map=idx_to_header_map
        )

        # Unpack the results into local variables for the rest of the function to use
        static_value_map = parsed_rules["static_value_map"]
        initial_static_col1_values = parsed_rules["initial_static_col1_values"]
        dynamic_mapping_rules = parsed_rules["dynamic_mapping_rules"]
        formula_rules = parsed_rules["formula_rules"]
        col1_index = parsed_rules["col1_index"]
        num_static_labels = parsed_rules["num_static_labels"]
        static_column_header_name = parsed_rules["static_column_header_name"]
        apply_special_border_rule = parsed_rules["apply_special_border_rule"]

        # --- Prepare Data Rows for Writing (Determine number of rows needed from source) ---
        # This section remains largely the same, preparing the `data_rows_prepared` list
        # which holds the *input* data, not the calculated formulas.
        desc_col_idx = col_id_map.get("col_desc") # Get the description column index
        data_rows_prepared, pallet_counts_for_rows, dynamic_desc_used, num_data_rows_from_source = prepare_data_rows(
            data_source_type=data_source_type,
            data_source=data_source,
            dynamic_mapping_rules=dynamic_mapping_rules,
            column_id_map=col_id_map,
            idx_to_header_map=idx_to_header_map,
            desc_col_idx=desc_col_idx,
            num_static_labels=num_static_labels,
            static_value_map=static_value_map
        )
# --- Determine Final Number of Data Rows ---
# The number of rows to process is the greater of the number of data rows or static labels.
        actual_rows_to_process = max(len(data_rows_prepared), num_static_labels)

        # Optional: Apply max_rows_to_fill constraint if it exists
        if max_rows_to_fill is not None and max_rows_to_fill >= 0:
            actual_rows_to_process = min(actual_rows_to_process, max_rows_to_fill)

        # Ensure pallet counts list matches the number of rows we intend to process
        if len(pallet_counts_for_rows) < actual_rows_to_process: pallet_counts_for_rows.extend([0] * (actual_rows_to_process - len(pallet_counts_for_rows)))
        elif len(pallet_counts_for_rows) > actual_rows_to_process: pallet_counts_for_rows = pallet_counts_for_rows[:actual_rows_to_process]

        # --- Calculate Total Rows to Insert and Row Indices ---
        total_rows_to_insert = 0
        current_row_offset = 0

        # Row after header (static/blank)
        if add_blank_after_header:
            row_after_header_idx = data_writing_start_row + current_row_offset
            total_rows_to_insert += 1
            current_row_offset += 1
        else:
            row_after_header_idx = -1 # Indicate no blank row

        # Data rows
        data_start_row = data_writing_start_row + current_row_offset
        if actual_rows_to_process > 0:
            data_end_row = data_start_row + actual_rows_to_process - 1
            total_rows_to_insert += actual_rows_to_process
            current_row_offset += actual_rows_to_process
        else:
            # No data rows to process (can happen if source is empty)
            data_end_row = data_start_row - 1 # Indicate no data rows

        # Row before footer (static/blank)
        if add_blank_before_footer:
            row_before_footer_idx = data_writing_start_row + current_row_offset
            total_rows_to_insert += 1
            current_row_offset += 1
        else:
            row_before_footer_idx = -1 # Indicate no blank row

        # Calculate final footer row index relative to where this chunk starts
        footer_row_final = data_writing_start_row + total_rows_to_insert
        total_rows_to_insert += 1 # Add 1 for the footer itself

        # --- Bulk Insert Rows --- # V11: Only insert if NOT pre-inserted by caller (i.e., for single-table modes)
        if data_source_type in ['aggregation', 'fob_aggregation']:
            if total_rows_to_insert > 0:
                try:
                    worksheet.insert_rows(data_writing_start_row, amount=total_rows_to_insert)
                    # Unmerge the block covering the inserted rows *before* the footer starts
                    safe_unmerge_block(worksheet, data_writing_start_row, footer_row_final - 1, num_columns)
                    print("Rows inserted and unmerged successfully.")
                except Exception as bulk_insert_err:
                    print(f"Error during single-table bulk row insert/unmerge: {bulk_insert_err}")
                    # Adjust fallback row calculation
                    fallback_row = max(header_info.get('second_row_index', 0) + 1, footer_row_final)
                    return False, fallback_row, -1, -1, 0

        # --- Fill Row After Header (if applicable) --- 

        # --- Prepare FOB Data Dictionary (inside loop now, safer) ---
        # Removed the premature preparation block here.
        # FOB data dict will be prepared inside the loop if data_source_type is fob_aggregation.

        # --- Fill Data Rows Loop ---
        if actual_rows_to_process > 0:
            print(f"--- DEBUG START LOOP (Sheet: {worksheet.title}) ---")
            print(f"  data_start_row: {data_start_row}")
            print(f"  actual_rows_to_process: {actual_rows_to_process}")
            print(f"  num_static_labels: {num_static_labels}")
            print(f"  col1_index: {col1_index}")
            print(f"  initial_static_col1_values: {initial_static_col1_values}")
            print(f"  data_source_type: {data_source_type}")
            # --- END DEBUG START LOOP ---
        try:
            # --- Create a reverse map from index to ID for easy lookups inside the loop ---
            idx_to_id_map = {v: k for k, v in col_id_map.items()}

            # --- Get column indices directly using their stable IDs ---
            no_col_idx = col_id_map.get("col_no")
            pallet_info_col_idx = col_id_map.get("col_pallet")
            
            # Get the list of column IDs that need to be formatted as text
            force_text_format_ids = sheet_styling_config.get("force_text_format_ids", []) if sheet_styling_config else []
            
            # Get the list of column IDs that should have a full grid border
            grid_column_ids = sheet_styling_config.get("column_ids_with_full_grid", []) if sheet_styling_config else []

            row_pallet_index = 0
            
            # --- Main Data-Writing Loop ---
            for i in range(actual_rows_to_process):
                target_row = data_start_row + i
                data_row_indices_written.append(target_row)
                row_data_dict = data_rows_prepared[i] if i < len(data_rows_prepared) else {}
                is_last_data_row = (i == actual_rows_to_process - 1)

                # --- Pallet Count Logic (remains the same) ---
                current_row_pallet_count = pallet_counts_for_rows[i] if i < len(pallet_counts_for_rows) else 0
                if current_row_pallet_count is not None and current_row_pallet_count > 0:
                    row_pallet_index += 1
                display_pallet_order = row_pallet_index
                
                # --- Cell Filling and Styling Loop ---
                for c_idx in range(1, num_columns + 1):
                    cell = worksheet.cell(row=target_row, column=c_idx)
                    current_id = idx_to_id_map.get(c_idx)
                    value_to_write = None

                    # --- Priority 1: Handle Initial Static Label Column ---
                    if i < num_static_labels and c_idx == col1_index:
                        cell.value = initial_static_col1_values[i]
                    
                    # --- Priority 2: Handle Regular Data Rows ---
                    else:
                        # Check for a formula rule first
                        if c_idx in formula_rules:
                            rule = formula_rules[c_idx]
                            formula_template = rule["template"]
                            input_ids = rule["input_ids"]
                            
                            formula_params = {'row': target_row}
                            valid_inputs = True
                            for idx, input_id in enumerate(input_ids):
                                input_col_idx = col_id_map.get(input_id)
                                if input_col_idx:
                                    formula_params[f'col_ref_{idx}'] = get_column_letter(input_col_idx)
                                else:
                                    valid_inputs = False; break
                            
                            value_to_write = f"={formula_template.format(**formula_params)}" if valid_inputs else "#REF!"

                        # Check for special, hardcoded column behaviors
                        elif c_idx == no_col_idx:
                            value_to_write = i + 1
                        elif c_idx == pallet_info_col_idx:
                            value_to_write = f"{display_pallet_order}-{local_chunk_pallets}"
                        
                        # Otherwise, get the value from the prepared data
                        else:
                            value_to_write = row_data_dict.get(c_idx)
                        
                        cell.value = value_to_write

                    # --- Apply Cell Styling and Formatting ---
                    if current_id in force_text_format_ids:
                        cell.number_format = FORMAT_TEXT
                    
                    _apply_cell_style(cell, current_id, sheet_styling_config)

                # --- Apply Border Rules for the entire row ---
                for c_idx_border in range(1, num_columns + 1):
                    cell_to_border = worksheet.cell(row=target_row, column=c_idx_border)
                    border_id = idx_to_id_map.get(c_idx_border)
                    
                    apply_grid = border_id and border_id in grid_column_ids
                    
                    top_b = thin_side if i == 0 else (thin_side if apply_grid else None)
                    bottom_b = thin_side if is_last_data_row else (thin_side if apply_grid else None)
                    
                    if apply_special_border_rule and c_idx_border == col1_index:
                        cell_to_border.border = Border(left=thin_side, right=thin_side, top=(thin_side if i == 0 else None), bottom=None)
                    elif apply_grid:
                        cell_to_border.border = thin_border
                    else:
                        cell_to_border.border = Border(left=thin_side, right=thin_side, top=top_b, bottom=bottom_b)

                # --- Apply explicit cell merging for this row ---
                if data_cell_merging_rules:
                    apply_explicit_data_cell_merges_by_id(
                        worksheet=worksheet,
                        row_num=target_row,
                        column_id_map=col_id_map,
                        num_total_columns=num_columns,
                        merge_rules_data_cells=data_cell_merging_rules,
                        sheet_styling_config=sheet_styling_config
                    )

        except Exception as fill_data_err:
            print(f"Error during data filling loop: {fill_data_err}\n{traceback.format_exc()}")
            return False, footer_row_final + 1, data_start_row, data_end_row, 0

    # Merge Description Column if the layout used fallback/static data
        if not dynamic_desc_used and data_start_row > 0 and data_end_row > data_start_row:
            desc_col_id = "col_desc" 
            if col_id_map.get(desc_col_id):
                merge_contiguous_cells_by_id(
                    worksheet=worksheet,
                    start_row=data_start_row,
                    end_row=data_end_row,
                    col_id_to_merge=desc_col_id,
                    column_id_map=col_id_map
                )

        # Always try to merge the Pallet Info Column if it exists
        if data_start_row > 0 and data_end_row > data_start_row:
            pallet_col_id = "col_pallet" 
            if col_id_map.get(pallet_col_id):
                merge_contiguous_cells_by_id(
                    worksheet=worksheet,
                    start_row=data_start_row,
                    end_row=data_end_row,
                    col_id_to_merge=pallet_col_id,
                    column_id_map=col_id_map
                )

# --- Fill Row Before Footer ---
        if add_blank_before_footer and row_before_footer_idx > 0:
            try:
                # Step 1: Fill the row with content (this applies default styles)
                fill_static_row(worksheet, row_before_footer_idx, num_columns, static_content_before_footer)
                
                # Step 2: Apply the special styling and borders for this specific row
                _style_row_before_footer(
                    worksheet=worksheet,
                    row_num=row_before_footer_idx,
                    num_columns=num_columns,
                    sheet_styling_config=sheet_styling_config,
                    idx_to_id_map=idx_to_id_map, # Pass the ID map here
                    col1_index=col1_index
                )
            except Exception as fill_bf_err:
                print(f"Warning: Error filling/styling row before footer: {fill_bf_err}")
        

        # --- Fill Footer Row --- (Keep existing logic)
        # The SUM formulas here should correctly sum the results of the formulas
        # written in the data rows above.
        if footer_row_final > 0:
            # Get the footer configuration object from the main sheet config
            footer_config = sheet_config.get("footer_configurations", {})
            data_range_to_sum = [(data_start_row, data_end_row)]

            pallet_count = 0
            if data_source_type == "processed_tables":
                pallet_count = local_chunk_pallets
            else:
                pallet_count = grand_total_pallets

            write_footer_row(
                worksheet=worksheet,
                footer_row_num=footer_row_final,
                header_info=header_info,
                sum_ranges=data_range_to_sum,
                footer_config=footer_config,
                pallet_count=pallet_count,
                fob_mode=data_source_type == "fob_aggregation"
            )
    # No need to pass font, alignment, num_columns, etc. as the
    # function gets this info from header_info and footer_config.
        # --- Apply Merges ---
        # Apply merges to row after header (if applicable)
        if add_blank_after_header and row_after_header_idx > 0 and merge_rules_after_header:
            apply_row_merges(worksheet, row_after_header_idx, num_columns, merge_rules_after_header)

        # Apply merges to row before footer (if applicable)
        target_row_for_bf_merge = row_before_footer_idx if add_blank_before_footer and row_before_footer_idx > 0 else -1
        if target_row_for_bf_merge > 0 and merge_rules_before_footer:
            apply_row_merges(worksheet, target_row_for_bf_merge, num_columns, merge_rules_before_footer)

        # Apply merges to the footer row itself (if applicable)
        if footer_row_final > 0 and merge_rules_footer:
            print(f"Applying footer merges to row {footer_row_final} with rules: {merge_rules_footer}") # Optional Debug
            try:
                apply_row_merges(worksheet, footer_row_final, num_columns, merge_rules_footer)
            except Exception as footer_merge_err:
                 print(f"Warning: Error applying footer merges: {footer_merge_err}")

        # --- Apply Row Heights --- (Keep existing)
        apply_row_heights(worksheet=worksheet, sheet_styling_config=sheet_styling_config, header_info=header_info, data_row_indices=data_row_indices_written, footer_row_index=footer_row_final, row_after_header_idx=row_after_header_idx, row_before_footer_idx=row_before_footer_idx)

        # --- Finalization --- (Keep existing)
        next_available_row_final = footer_row_final + 1
        if actual_rows_to_process == 0: data_start_row = -1; data_end_row = -1
        return True, next_available_row_final, data_start_row, data_end_row, local_chunk_pallets

    except Exception as e:
        # --- Error Handling --- (Keep existing)
        print(f"Critical error in fill_invoice_data: {e}\n{traceback.format_exc()}")
        fallback_row = header_info.get('second_row_index', 0) + 1; frf_local = locals().get('footer_row_final', -1)
        if frf_local > 0: fallback_row = max(fallback_row, frf_local + 1)
        else: est_footer = locals().get('initial_insert_point', fallback_row) + locals().get('total_rows_to_insert', 0); fallback_row = max(fallback_row, est_footer)
        return False, fallback_row, -1, -1, 0
